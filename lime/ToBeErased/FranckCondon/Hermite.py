#import sympy as sym
# from scipy.special import hermite

from mpmath import hermite
import numpy as np

# def DHermite(n):
#     """ Physicist's Hermite polynomials generated by dynamic programming
#         Until we can install sympy, cannot deal with n>10
#     """
#     d = {}
#     d[0] = lambda x: 1+0*x
#     d[1] = lambda x: 2*x
#     d[2] = lambda x: 4*x**2 - 2
#     d[3] = lambda x: 8*x**3 - 12*x
#     d[4] = lambda x: 16*x**4 - 48*x**2 + 12
#     d[5] = lambda x: 32*x**5 - 160*x**3 + 120*x
#     d[6] = lambda x: 64*x**6 - 480*x**4 + 720*x**2 - 120
#     d[7] = lambda x: 128*x**7 - 1344*x**5 + 3360*x**3 - 1680*x
#     d[8] = lambda x: 256*x**8 - 3584*x**6 + 13440*x**4 - 13440*x**2 + 1680
#     d[9] = lambda x: 512*x**9 - 9216*x**7 + 48384*x**5 - 80640*x**3 + 30240*x
#     d[10] = lambda x: 1024*x**10 - 23040*x**8 + 161280*x**6 - 403200*x**4 + 302400*x**2 - 30240

#     if (n > 10):
#         print("Error, n > 10")
#         return
#        #  X = sym.Symbol('X')
# #         for i in range(10, n+1):
# #             d[i] = 2*x*d[i-1] - d[i-1].diff(x, 1)
# #     H = sym.simplify(d[n])
# #     h = sym.lambdify(x, H)
# #     return h
#     return d[n]

def iHermite(n):
    """
    Generates Fn(x) such that Fn(x) = (j**n)*Hn(jx)
    Which also follows the recurrence Fn(x) = -2xFn-1(x) + 2(n-1)Fn-2(x)
    """
    #x = sym.Symbol('x')
#     d = {}
#     d[0] = lambda x: 1 # DHermite(0)(0)
#     d[1] = lambda x: -2*x # 1j*DHermite(1)(1j)
#     d[2] = lambda x: 4*x**2 + 2
#     d[3] = lambda x: -8*x**3 - 12*x
#     d[4] = lambda x: 16*x**4 + 48*x**2 + 12
#     d[5] = lambda x: -32*x**5 - 160*x**3 - 120*x
#     d[6] = lambda x: 64*x**6 + 480*x**4 + 720*x**2 + 120
#     d[7] = lambda x: -128*x**7 - 1344*x**5 - 3360*x**3 - 1680*x
#     d[8] = lambda x: 256*x**8 + 3584*x**6 + 13440*x**4 + 13440*x**2 + 1680
#     d[9] = lambda x: -512*x**9 - 9216*x**7 - 48384*x**5 - 80640*x**3 - 30240*x
#     d[10] = lambda x: 1024*x**10 + 23040*x**8 + 161280*x**6 + 403200*x**4 + 302400*x**2 + 30240
#     if (n > 10):
#         print("Error, n>0")
#         return
# ##         for i in range(11, n+1):
# ##             d[i] = -2*x*d[i-1] + 2*(i-1)*d[i-2]
# ##     F = sym.simplify(d[n])
# ##     f = sym.lambdify(x, F)
#     return d[n]

    return lambda x: np.real((1j)**n * hermite(n, 1j * x))


if __name__ == '__main__':

    import numpy as np
    from scipy import special
    
    x = np.linspace(-1,1)

    from lime.style import curve

    h = iHermite(3)
    

